{"ast":null,"code":"const debug = require(\"debug\")(\"streamroller:RollingFileWriteStream\");\n\nconst fs = require(\"fs-extra\");\n\nconst path = require(\"path\");\n\nconst newNow = require(\"./now\");\n\nconst format = require(\"date-format\");\n\nconst {\n  Writable\n} = require(\"stream\");\n\nconst fileNameFormatter = require(\"./fileNameFormatter\");\n\nconst fileNameParser = require(\"./fileNameParser\");\n\nconst moveAndMaybeCompressFile = require(\"./moveAndMaybeCompressFile\");\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inherits from stream.Writable\n */\n\n\nclass RollingFileWriteStream extends Writable {\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  constructor(filePath, options) {\n    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);\n    super(options);\n    this.options = this._parseOption(options);\n    this.fileObject = path.parse(filePath);\n\n    if (this.fileObject.dir === \"\") {\n      this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n\n    this.fileFormatter = fileNameFormatter({\n      file: this.fileObject,\n      alwaysIncludeDate: this.options.alwaysIncludePattern,\n      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,\n      compress: this.options.compress,\n      keepFileExt: this.options.keepFileExt\n    });\n    this.fileNameParser = fileNameParser({\n      file: this.fileObject,\n      keepFileExt: this.options.keepFileExt,\n      pattern: this.options.pattern\n    });\n    this.state = {\n      currentSize: 0\n    };\n\n    if (this.options.pattern) {\n      this.state.currentDate = format(this.options.pattern, newNow());\n    }\n\n    this.filename = this.fileFormatter({\n      index: 0,\n      date: this.state.currentDate\n    });\n\n    if ([\"a\", \"a+\", \"as\", \"as+\"].includes(this.options.flags)) {\n      this._setExistingSizeAndDate();\n    }\n\n    debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);\n\n    this._renewWriteStream();\n  }\n\n  _setExistingSizeAndDate() {\n    try {\n      const stats = fs.statSync(this.filename);\n      this.state.currentSize = stats.size;\n\n      if (this.options.pattern) {\n        this.state.currentDate = format(this.options.pattern, stats.mtime);\n      }\n    } catch (e) {\n      //file does not exist, that's fine - move along\n      return;\n    }\n  }\n\n  _parseOption(rawOptions) {\n    const defaultOptions = {\n      maxSize: Number.MAX_SAFE_INTEGER,\n      numToKeep: Number.MAX_SAFE_INTEGER,\n      encoding: \"utf8\",\n      mode: parseInt(\"0644\", 8),\n      flags: \"a\",\n      compress: false,\n      keepFileExt: false,\n      alwaysIncludePattern: false\n    };\n    const options = Object.assign({}, defaultOptions, rawOptions);\n\n    if (options.maxSize <= 0) {\n      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);\n    }\n\n    if (options.numToKeep <= 0) {\n      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);\n    }\n\n    debug(`_parseOption: creating stream with option=${JSON.stringify(options)}`);\n    return options;\n  }\n\n  _final(callback) {\n    this.currentFileStream.end(\"\", this.options.encoding, callback);\n  }\n\n  _write(chunk, encoding, callback) {\n    this._shouldRoll().then(() => {\n      debug(`_write: writing chunk. ` + `file=${this.currentFileStream.path} ` + `state=${JSON.stringify(this.state)} ` + `chunk=${chunk}`);\n      this.currentFileStream.write(chunk, encoding, e => {\n        this.state.currentSize += chunk.length;\n        callback(e);\n      });\n    });\n  }\n\n  async _shouldRoll() {\n    if (this._dateChanged() || this._tooBig()) {\n      debug(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);\n      await this._roll();\n    }\n  }\n\n  _dateChanged() {\n    return this.state.currentDate && this.state.currentDate !== format(this.options.pattern, newNow());\n  }\n\n  _tooBig() {\n    return this.state.currentSize >= this.options.maxSize;\n  }\n\n  _roll() {\n    debug(`_roll: closing the current stream`);\n    return new Promise((resolve, reject) => {\n      this.currentFileStream.end(\"\", this.options.encoding, () => {\n        this._moveOldFiles().then(resolve).catch(reject);\n      });\n    });\n  }\n\n  async _moveOldFiles() {\n    const files = await this._getExistingFiles();\n    const todaysFiles = this.state.currentDate ? files.filter(f => f.date === this.state.currentDate) : files;\n\n    for (let i = todaysFiles.length; i >= 0; i--) {\n      debug(`_moveOldFiles: i = ${i}`);\n      const sourceFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i\n      });\n      const targetFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i + 1\n      });\n      await moveAndMaybeCompressFile(sourceFilePath, targetFilePath, this.options.compress && i === 0);\n    }\n\n    this.state.currentSize = 0;\n    this.state.currentDate = this.state.currentDate ? format(this.options.pattern, newNow()) : null;\n    debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);\n\n    this._renewWriteStream(); // wait for the file to be open before cleaning up old ones,\n    // otherwise the daysToKeep calculations can be off\n\n\n    await new Promise((resolve, reject) => {\n      this.currentFileStream.write(\"\", \"utf8\", () => {\n        this._clean().then(resolve).catch(reject);\n      });\n    });\n  } // Sorted from the oldest to the latest\n\n\n  async _getExistingFiles() {\n    const files = await fs.readdir(this.fileObject.dir).catch(() => []);\n    debug(`_getExistingFiles: files=${files}`);\n    const existingFileDetails = files.map(n => this.fileNameParser(n)).filter(n => n);\n\n    const getKey = n => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;\n\n    existingFileDetails.sort((a, b) => getKey(a) - getKey(b));\n    return existingFileDetails;\n  }\n\n  _renewWriteStream() {\n    fs.ensureDirSync(this.fileObject.dir);\n    const filePath = this.fileFormatter({\n      date: this.state.currentDate,\n      index: 0\n    });\n    const ops = {\n      flags: this.options.flags,\n      encoding: this.options.encoding,\n      mode: this.options.mode\n    };\n    this.currentFileStream = fs.createWriteStream(filePath, ops);\n    this.currentFileStream.on(\"error\", e => {\n      this.emit(\"error\", e);\n    });\n  }\n\n  async _clean() {\n    const existingFileDetails = await this._getExistingFiles();\n    debug(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);\n    debug(\"_clean: existing files are: \", existingFileDetails);\n\n    if (this._tooManyFiles(existingFileDetails.length)) {\n      const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep - 1).map(f => path.format({\n        dir: this.fileObject.dir,\n        base: f.filename\n      }));\n      await deleteFiles(fileNamesToRemove);\n    }\n  }\n\n  _tooManyFiles(numFiles) {\n    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;\n  }\n\n}\n\nconst deleteFiles = fileNames => {\n  debug(`deleteFiles: files to delete: ${fileNames}`);\n  return Promise.all(fileNames.map(f => fs.unlink(f).catch(e => {\n    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);\n  })));\n};\n\nmodule.exports = RollingFileWriteStream;","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/streamroller/lib/RollingFileWriteStream.js"],"names":["debug","require","fs","path","newNow","format","Writable","fileNameFormatter","fileNameParser","moveAndMaybeCompressFile","RollingFileWriteStream","constructor","filePath","options","_parseOption","fileObject","parse","dir","join","process","cwd","fileFormatter","file","alwaysIncludeDate","alwaysIncludePattern","needsIndex","maxSize","Number","MAX_SAFE_INTEGER","compress","keepFileExt","pattern","state","currentSize","currentDate","filename","index","date","includes","flags","_setExistingSizeAndDate","JSON","stringify","_renewWriteStream","stats","statSync","size","mtime","e","rawOptions","defaultOptions","numToKeep","encoding","mode","parseInt","Object","assign","Error","_final","callback","currentFileStream","end","_write","chunk","_shouldRoll","then","write","length","_dateChanged","_tooBig","_roll","Promise","resolve","reject","_moveOldFiles","catch","files","_getExistingFiles","todaysFiles","filter","f","i","sourceFilePath","targetFilePath","_clean","readdir","existingFileDetails","map","n","getKey","timestamp","getTime","sort","a","b","ensureDirSync","ops","createWriteStream","on","emit","_tooManyFiles","fileNamesToRemove","slice","base","deleteFiles","numFiles","fileNames","all","unlink","module","exports"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,qCAAjB,CAAd;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,UAAD,CAAlB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAeL,OAAO,CAAC,QAAD,CAA5B;;AACA,MAAMM,iBAAiB,GAAGN,OAAO,CAAC,qBAAD,CAAjC;;AACA,MAAMO,cAAc,GAAGP,OAAO,CAAC,kBAAD,CAA9B;;AACA,MAAMQ,wBAAwB,GAAGR,OAAO,CAAC,4BAAD,CAAxC;AAEA;AACA;AACA;AACA;;;AACA,MAAMS,sBAAN,SAAqCJ,QAArC,CAA8C;AAC5C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEK,EAAAA,WAAW,CAACC,QAAD,EAAWC,OAAX,EAAoB;AAC7Bb,IAAAA,KAAK,CAAE,sDAAqDY,QAAS,EAAhE,CAAL;AACA,UAAMC,OAAN;AACA,SAAKA,OAAL,GAAe,KAAKC,YAAL,CAAkBD,OAAlB,CAAf;AACA,SAAKE,UAAL,GAAkBZ,IAAI,CAACa,KAAL,CAAWJ,QAAX,CAAlB;;AACA,QAAI,KAAKG,UAAL,CAAgBE,GAAhB,KAAwB,EAA5B,EAAgC;AAC9B,WAAKF,UAAL,GAAkBZ,IAAI,CAACa,KAAL,CAAWb,IAAI,CAACe,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAAyBR,QAAzB,CAAX,CAAlB;AACD;;AACD,SAAKS,aAAL,GAAqBd,iBAAiB,CAAC;AACrCe,MAAAA,IAAI,EAAE,KAAKP,UAD0B;AAErCQ,MAAAA,iBAAiB,EAAE,KAAKV,OAAL,CAAaW,oBAFK;AAGrCC,MAAAA,UAAU,EAAE,KAAKZ,OAAL,CAAaa,OAAb,GAAuBC,MAAM,CAACC,gBAHL;AAIrCC,MAAAA,QAAQ,EAAE,KAAKhB,OAAL,CAAagB,QAJc;AAKrCC,MAAAA,WAAW,EAAE,KAAKjB,OAAL,CAAaiB;AALW,KAAD,CAAtC;AAQA,SAAKtB,cAAL,GAAsBA,cAAc,CAAC;AACnCc,MAAAA,IAAI,EAAE,KAAKP,UADwB;AAEnCe,MAAAA,WAAW,EAAE,KAAKjB,OAAL,CAAaiB,WAFS;AAGnCC,MAAAA,OAAO,EAAE,KAAKlB,OAAL,CAAakB;AAHa,KAAD,CAApC;AAMA,SAAKC,KAAL,GAAa;AACXC,MAAAA,WAAW,EAAE;AADF,KAAb;;AAIA,QAAI,KAAKpB,OAAL,CAAakB,OAAjB,EAA0B;AACxB,WAAKC,KAAL,CAAWE,WAAX,GAAyB7B,MAAM,CAAC,KAAKQ,OAAL,CAAakB,OAAd,EAAuB3B,MAAM,EAA7B,CAA/B;AACD;;AAED,SAAK+B,QAAL,GAAgB,KAAKd,aAAL,CAAmB;AACjCe,MAAAA,KAAK,EAAE,CAD0B;AAEjCC,MAAAA,IAAI,EAAE,KAAKL,KAAL,CAAWE;AAFgB,KAAnB,CAAhB;;AAIA,QAAI,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAkB,KAAlB,EAAyBI,QAAzB,CAAkC,KAAKzB,OAAL,CAAa0B,KAA/C,CAAJ,EAA2D;AACzD,WAAKC,uBAAL;AACD;;AAEDxC,IAAAA,KAAK,CACF,gCAA+B,KAAKmC,QAAS,WAAUM,IAAI,CAACC,SAAL,CACtD,KAAKV,KADiD,CAEtD,EAHC,CAAL;;AAKA,SAAKW,iBAAL;AACD;;AAEDH,EAAAA,uBAAuB,GAAG;AACxB,QAAI;AACF,YAAMI,KAAK,GAAG1C,EAAE,CAAC2C,QAAH,CAAY,KAAKV,QAAjB,CAAd;AACA,WAAKH,KAAL,CAAWC,WAAX,GAAyBW,KAAK,CAACE,IAA/B;;AACA,UAAI,KAAKjC,OAAL,CAAakB,OAAjB,EAA0B;AACxB,aAAKC,KAAL,CAAWE,WAAX,GAAyB7B,MAAM,CAAC,KAAKQ,OAAL,CAAakB,OAAd,EAAuBa,KAAK,CAACG,KAA7B,CAA/B;AACD;AACF,KAND,CAME,OAAOC,CAAP,EAAU;AACV;AACA;AACD;AACF;;AAEDlC,EAAAA,YAAY,CAACmC,UAAD,EAAa;AACvB,UAAMC,cAAc,GAAG;AACrBxB,MAAAA,OAAO,EAAEC,MAAM,CAACC,gBADK;AAErBuB,MAAAA,SAAS,EAAExB,MAAM,CAACC,gBAFG;AAGrBwB,MAAAA,QAAQ,EAAE,MAHW;AAIrBC,MAAAA,IAAI,EAAEC,QAAQ,CAAC,MAAD,EAAS,CAAT,CAJO;AAKrBf,MAAAA,KAAK,EAAE,GALc;AAMrBV,MAAAA,QAAQ,EAAE,KANW;AAOrBC,MAAAA,WAAW,EAAE,KAPQ;AAQrBN,MAAAA,oBAAoB,EAAE;AARD,KAAvB;AAUA,UAAMX,OAAO,GAAG0C,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,cAAlB,EAAkCD,UAAlC,CAAhB;;AACA,QAAIpC,OAAO,CAACa,OAAR,IAAmB,CAAvB,EAA0B;AACxB,YAAM,IAAI+B,KAAJ,CAAW,oBAAmB5C,OAAO,CAACa,OAAQ,iBAA9C,CAAN;AACD;;AACD,QAAIb,OAAO,CAACsC,SAAR,IAAqB,CAAzB,EAA4B;AAC1B,YAAM,IAAIM,KAAJ,CAAW,sBAAqB5C,OAAO,CAACsC,SAAU,iBAAlD,CAAN;AACD;;AACDnD,IAAAA,KAAK,CACF,6CAA4CyC,IAAI,CAACC,SAAL,CAAe7B,OAAf,CAAwB,EADlE,CAAL;AAGA,WAAOA,OAAP;AACD;;AAED6C,EAAAA,MAAM,CAACC,QAAD,EAAW;AACf,SAAKC,iBAAL,CAAuBC,GAAvB,CAA2B,EAA3B,EAA+B,KAAKhD,OAAL,CAAauC,QAA5C,EAAsDO,QAAtD;AACD;;AAEDG,EAAAA,MAAM,CAACC,KAAD,EAAQX,QAAR,EAAkBO,QAAlB,EAA4B;AAChC,SAAKK,WAAL,GAAmBC,IAAnB,CAAwB,MAAM;AAC5BjE,MAAAA,KAAK,CACF,yBAAD,GACG,QAAO,KAAK4D,iBAAL,CAAuBzD,IAAK,GADtC,GAEG,SAAQsC,IAAI,CAACC,SAAL,CAAe,KAAKV,KAApB,CAA2B,GAFtC,GAGG,SAAQ+B,KAAM,EAJd,CAAL;AAMA,WAAKH,iBAAL,CAAuBM,KAAvB,CAA6BH,KAA7B,EAAoCX,QAApC,EAA8CJ,CAAC,IAAI;AACjD,aAAKhB,KAAL,CAAWC,WAAX,IAA0B8B,KAAK,CAACI,MAAhC;AACAR,QAAAA,QAAQ,CAACX,CAAD,CAAR;AACD,OAHD;AAID,KAXD;AAYD;;AAEgB,QAAXgB,WAAW,GAAG;AAClB,QAAI,KAAKI,YAAL,MAAuB,KAAKC,OAAL,EAA3B,EAA2C;AACzCrE,MAAAA,KAAK,CACF,6CAA4C,KAAKoE,YAAL,EAAoB,eAAc,KAAKC,OAAL,EAAe,EAD3F,CAAL;AAGA,YAAM,KAAKC,KAAL,EAAN;AACD;AACF;;AAEDF,EAAAA,YAAY,GAAG;AACb,WACE,KAAKpC,KAAL,CAAWE,WAAX,IACA,KAAKF,KAAL,CAAWE,WAAX,KAA2B7B,MAAM,CAAC,KAAKQ,OAAL,CAAakB,OAAd,EAAuB3B,MAAM,EAA7B,CAFnC;AAID;;AAEDiE,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKrC,KAAL,CAAWC,WAAX,IAA0B,KAAKpB,OAAL,CAAaa,OAA9C;AACD;;AAED4C,EAAAA,KAAK,GAAG;AACNtE,IAAAA,KAAK,CAAE,mCAAF,CAAL;AACA,WAAO,IAAIuE,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKb,iBAAL,CAAuBC,GAAvB,CAA2B,EAA3B,EAA+B,KAAKhD,OAAL,CAAauC,QAA5C,EAAsD,MAAM;AAC1D,aAAKsB,aAAL,GACGT,IADH,CACQO,OADR,EAEGG,KAFH,CAESF,MAFT;AAGD,OAJD;AAKD,KANM,CAAP;AAOD;;AAEkB,QAAbC,aAAa,GAAG;AACpB,UAAME,KAAK,GAAG,MAAM,KAAKC,iBAAL,EAApB;AACA,UAAMC,WAAW,GAAG,KAAK9C,KAAL,CAAWE,WAAX,GAChB0C,KAAK,CAACG,MAAN,CAAaC,CAAC,IAAIA,CAAC,CAAC3C,IAAF,KAAW,KAAKL,KAAL,CAAWE,WAAxC,CADgB,GAEhB0C,KAFJ;;AAGA,SAAK,IAAIK,CAAC,GAAGH,WAAW,CAACX,MAAzB,EAAiCc,CAAC,IAAI,CAAtC,EAAyCA,CAAC,EAA1C,EAA8C;AAC5CjF,MAAAA,KAAK,CAAE,sBAAqBiF,CAAE,EAAzB,CAAL;AACA,YAAMC,cAAc,GAAG,KAAK7D,aAAL,CAAmB;AACxCgB,QAAAA,IAAI,EAAE,KAAKL,KAAL,CAAWE,WADuB;AAExCE,QAAAA,KAAK,EAAE6C;AAFiC,OAAnB,CAAvB;AAIA,YAAME,cAAc,GAAG,KAAK9D,aAAL,CAAmB;AACxCgB,QAAAA,IAAI,EAAE,KAAKL,KAAL,CAAWE,WADuB;AAExCE,QAAAA,KAAK,EAAE6C,CAAC,GAAG;AAF6B,OAAnB,CAAvB;AAKA,YAAMxE,wBAAwB,CAC5ByE,cAD4B,EAE5BC,cAF4B,EAG5B,KAAKtE,OAAL,CAAagB,QAAb,IAAyBoD,CAAC,KAAK,CAHH,CAA9B;AAKD;;AAED,SAAKjD,KAAL,CAAWC,WAAX,GAAyB,CAAzB;AACA,SAAKD,KAAL,CAAWE,WAAX,GAAyB,KAAKF,KAAL,CAAWE,WAAX,GACrB7B,MAAM,CAAC,KAAKQ,OAAL,CAAakB,OAAd,EAAuB3B,MAAM,EAA7B,CADe,GAErB,IAFJ;AAGAJ,IAAAA,KAAK,CACF,gDAA+CyC,IAAI,CAACC,SAAL,CAC9C,KAAKV,KADyC,CAE9C,EAHC,CAAL;;AAKA,SAAKW,iBAAL,GAhCoB,CAiCpB;AACA;;;AACA,UAAM,IAAI4B,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrC,WAAKb,iBAAL,CAAuBM,KAAvB,CAA6B,EAA7B,EAAiC,MAAjC,EAAyC,MAAM;AAC7C,aAAKkB,MAAL,GACGnB,IADH,CACQO,OADR,EAEGG,KAFH,CAESF,MAFT;AAGD,OAJD;AAKD,KANK,CAAN;AAOD,GA/L2C,CAiM5C;;;AACuB,QAAjBI,iBAAiB,GAAG;AACxB,UAAMD,KAAK,GAAG,MAAM1E,EAAE,CAACmF,OAAH,CAAW,KAAKtE,UAAL,CAAgBE,GAA3B,EAAgC0D,KAAhC,CAAsC,MAAM,EAA5C,CAApB;AAEA3E,IAAAA,KAAK,CAAE,4BAA2B4E,KAAM,EAAnC,CAAL;AACA,UAAMU,mBAAmB,GAAGV,KAAK,CAC9BW,GADyB,CACrBC,CAAC,IAAI,KAAKhF,cAAL,CAAoBgF,CAApB,CADgB,EAEzBT,MAFyB,CAElBS,CAAC,IAAIA,CAFa,CAA5B;;AAIA,UAAMC,MAAM,GAAGD,CAAC,IACd,CAACA,CAAC,CAACE,SAAF,GAAcF,CAAC,CAACE,SAAhB,GAA4BtF,MAAM,GAAGuF,OAAT,EAA7B,IAAmDH,CAAC,CAACpD,KADvD;;AAEAkD,IAAAA,mBAAmB,CAACM,IAApB,CAAyB,CAACC,CAAD,EAAIC,CAAJ,KAAUL,MAAM,CAACI,CAAD,CAAN,GAAYJ,MAAM,CAACK,CAAD,CAArD;AAEA,WAAOR,mBAAP;AACD;;AAED3C,EAAAA,iBAAiB,GAAG;AAClBzC,IAAAA,EAAE,CAAC6F,aAAH,CAAiB,KAAKhF,UAAL,CAAgBE,GAAjC;AACA,UAAML,QAAQ,GAAG,KAAKS,aAAL,CAAmB;AAClCgB,MAAAA,IAAI,EAAE,KAAKL,KAAL,CAAWE,WADiB;AAElCE,MAAAA,KAAK,EAAE;AAF2B,KAAnB,CAAjB;AAIA,UAAM4D,GAAG,GAAG;AACVzD,MAAAA,KAAK,EAAE,KAAK1B,OAAL,CAAa0B,KADV;AAEVa,MAAAA,QAAQ,EAAE,KAAKvC,OAAL,CAAauC,QAFb;AAGVC,MAAAA,IAAI,EAAE,KAAKxC,OAAL,CAAawC;AAHT,KAAZ;AAKA,SAAKO,iBAAL,GAAyB1D,EAAE,CAAC+F,iBAAH,CAAqBrF,QAArB,EAA+BoF,GAA/B,CAAzB;AACA,SAAKpC,iBAAL,CAAuBsC,EAAvB,CAA0B,OAA1B,EAAmClD,CAAC,IAAI;AACtC,WAAKmD,IAAL,CAAU,OAAV,EAAmBnD,CAAnB;AACD,KAFD;AAGD;;AAEW,QAANoC,MAAM,GAAG;AACb,UAAME,mBAAmB,GAAG,MAAM,KAAKT,iBAAL,EAAlC;AACA7E,IAAAA,KAAK,CACF,uBAAsB,KAAKa,OAAL,CAAasC,SAAU,qBAAoBmC,mBAAmB,CAACnB,MAAO,EAD1F,CAAL;AAGAnE,IAAAA,KAAK,CAAC,8BAAD,EAAiCsF,mBAAjC,CAAL;;AACA,QAAI,KAAKc,aAAL,CAAmBd,mBAAmB,CAACnB,MAAvC,CAAJ,EAAoD;AAClD,YAAMkC,iBAAiB,GAAGf,mBAAmB,CAC1CgB,KADuB,CACjB,CADiB,EACdhB,mBAAmB,CAACnB,MAApB,GAA6B,KAAKtD,OAAL,CAAasC,SAA1C,GAAsD,CADxC,EAEvBoC,GAFuB,CAEnBP,CAAC,IAAI7E,IAAI,CAACE,MAAL,CAAY;AAAEY,QAAAA,GAAG,EAAE,KAAKF,UAAL,CAAgBE,GAAvB;AAA4BsF,QAAAA,IAAI,EAAEvB,CAAC,CAAC7C;AAApC,OAAZ,CAFc,CAA1B;AAGA,YAAMqE,WAAW,CAACH,iBAAD,CAAjB;AACD;AACF;;AAEDD,EAAAA,aAAa,CAACK,QAAD,EAAW;AACtB,WAAO,KAAK5F,OAAL,CAAasC,SAAb,GAAyB,CAAzB,IAA8BsD,QAAQ,GAAG,KAAK5F,OAAL,CAAasC,SAA7D;AACD;;AAlP2C;;AAqP9C,MAAMqD,WAAW,GAAGE,SAAS,IAAI;AAC/B1G,EAAAA,KAAK,CAAE,iCAAgC0G,SAAU,EAA5C,CAAL;AACA,SAAOnC,OAAO,CAACoC,GAAR,CAAYD,SAAS,CAACnB,GAAV,CAAcP,CAAC,IAAI9E,EAAE,CAAC0G,MAAH,CAAU5B,CAAV,EAAaL,KAAb,CAAoB3B,CAAD,IAAO;AAC9DhD,IAAAA,KAAK,CAAE,qCAAoCgF,CAAE,yBAAwBhC,CAAE,EAAlE,CAAL;AACD,GAFqC,CAAnB,CAAZ,CAAP;AAGD,CALD;;AAOA6D,MAAM,CAACC,OAAP,GAAiBpG,sBAAjB","sourcesContent":["const debug = require(\"debug\")(\"streamroller:RollingFileWriteStream\");\nconst fs = require(\"fs-extra\");\nconst path = require(\"path\");\nconst newNow = require(\"./now\");\nconst format = require(\"date-format\");\nconst { Writable } = require(\"stream\");\nconst fileNameFormatter = require(\"./fileNameFormatter\");\nconst fileNameParser = require(\"./fileNameParser\");\nconst moveAndMaybeCompressFile = require(\"./moveAndMaybeCompressFile\");\n\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inherits from stream.Writable\n */\nclass RollingFileWriteStream extends Writable {\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  constructor(filePath, options) {\n    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);\n    super(options);\n    this.options = this._parseOption(options);\n    this.fileObject = path.parse(filePath);\n    if (this.fileObject.dir === \"\") {\n      this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n    this.fileFormatter = fileNameFormatter({\n      file: this.fileObject,\n      alwaysIncludeDate: this.options.alwaysIncludePattern,\n      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,\n      compress: this.options.compress,\n      keepFileExt: this.options.keepFileExt\n    });\n\n    this.fileNameParser = fileNameParser({\n      file: this.fileObject,\n      keepFileExt: this.options.keepFileExt,\n      pattern: this.options.pattern\n    });\n\n    this.state = {\n      currentSize: 0\n    };\n\n    if (this.options.pattern) {\n      this.state.currentDate = format(this.options.pattern, newNow());\n    }\n\n    this.filename = this.fileFormatter({\n      index: 0,\n      date: this.state.currentDate\n    });\n    if ([\"a\", \"a+\", \"as\", \"as+\"].includes(this.options.flags)) {\n      this._setExistingSizeAndDate();\n    }\n\n    debug(\n      `constructor: create new file ${this.filename}, state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n  }\n\n  _setExistingSizeAndDate() {\n    try {\n      const stats = fs.statSync(this.filename);\n      this.state.currentSize = stats.size;\n      if (this.options.pattern) {\n        this.state.currentDate = format(this.options.pattern, stats.mtime);\n      }\n    } catch (e) {\n      //file does not exist, that's fine - move along\n      return;\n    }\n  }\n\n  _parseOption(rawOptions) {\n    const defaultOptions = {\n      maxSize: Number.MAX_SAFE_INTEGER,\n      numToKeep: Number.MAX_SAFE_INTEGER,\n      encoding: \"utf8\",\n      mode: parseInt(\"0644\", 8),\n      flags: \"a\",\n      compress: false,\n      keepFileExt: false,\n      alwaysIncludePattern: false\n    };\n    const options = Object.assign({}, defaultOptions, rawOptions);\n    if (options.maxSize <= 0) {\n      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);\n    }\n    if (options.numToKeep <= 0) {\n      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);\n    }\n    debug(\n      `_parseOption: creating stream with option=${JSON.stringify(options)}`\n    );\n    return options;\n  }\n\n  _final(callback) {\n    this.currentFileStream.end(\"\", this.options.encoding, callback);\n  }\n\n  _write(chunk, encoding, callback) {\n    this._shouldRoll().then(() => {\n      debug(\n        `_write: writing chunk. ` +\n          `file=${this.currentFileStream.path} ` +\n          `state=${JSON.stringify(this.state)} ` +\n          `chunk=${chunk}`\n      );\n      this.currentFileStream.write(chunk, encoding, e => {\n        this.state.currentSize += chunk.length;\n        callback(e);\n      });\n    });\n  }\n\n  async _shouldRoll() {\n    if (this._dateChanged() || this._tooBig()) {\n      debug(\n        `_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`\n      );\n      await this._roll();\n    }\n  }\n\n  _dateChanged() {\n    return (\n      this.state.currentDate &&\n      this.state.currentDate !== format(this.options.pattern, newNow())\n    );\n  }\n\n  _tooBig() {\n    return this.state.currentSize >= this.options.maxSize;\n  }\n\n  _roll() {\n    debug(`_roll: closing the current stream`);\n    return new Promise((resolve, reject) => {\n      this.currentFileStream.end(\"\", this.options.encoding, () => {\n        this._moveOldFiles()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  async _moveOldFiles() {\n    const files = await this._getExistingFiles();\n    const todaysFiles = this.state.currentDate\n      ? files.filter(f => f.date === this.state.currentDate)\n      : files;\n    for (let i = todaysFiles.length; i >= 0; i--) {\n      debug(`_moveOldFiles: i = ${i}`);\n      const sourceFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i\n      });\n      const targetFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i + 1\n      });\n\n      await moveAndMaybeCompressFile(\n        sourceFilePath,\n        targetFilePath,\n        this.options.compress && i === 0\n      );\n    }\n\n    this.state.currentSize = 0;\n    this.state.currentDate = this.state.currentDate\n      ? format(this.options.pattern, newNow())\n      : null;\n    debug(\n      `_moveOldFiles: finished rolling files. state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n    // wait for the file to be open before cleaning up old ones,\n    // otherwise the daysToKeep calculations can be off\n    await new Promise((resolve, reject) => {\n      this.currentFileStream.write(\"\", \"utf8\", () => {\n        this._clean()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  // Sorted from the oldest to the latest\n  async _getExistingFiles() {\n    const files = await fs.readdir(this.fileObject.dir).catch(() => []);\n\n    debug(`_getExistingFiles: files=${files}`);\n    const existingFileDetails = files\n      .map(n => this.fileNameParser(n))\n      .filter(n => n);\n\n    const getKey = n =>\n      (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;\n    existingFileDetails.sort((a, b) => getKey(a) - getKey(b));\n\n    return existingFileDetails;\n  }\n\n  _renewWriteStream() {\n    fs.ensureDirSync(this.fileObject.dir);\n    const filePath = this.fileFormatter({\n      date: this.state.currentDate,\n      index: 0\n    });\n    const ops = {\n      flags: this.options.flags,\n      encoding: this.options.encoding,\n      mode: this.options.mode\n    };\n    this.currentFileStream = fs.createWriteStream(filePath, ops);\n    this.currentFileStream.on(\"error\", e => {\n      this.emit(\"error\", e);\n    });\n  }\n\n  async _clean() {\n    const existingFileDetails = await this._getExistingFiles();\n    debug(\n      `_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`\n    );\n    debug(\"_clean: existing files are: \", existingFileDetails);\n    if (this._tooManyFiles(existingFileDetails.length)) {\n      const fileNamesToRemove = existingFileDetails\n        .slice(0, existingFileDetails.length - this.options.numToKeep - 1)\n        .map(f => path.format({ dir: this.fileObject.dir, base: f.filename }));\n      await deleteFiles(fileNamesToRemove);\n    }\n  }\n\n  _tooManyFiles(numFiles) {\n    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;\n  }\n}\n\nconst deleteFiles = fileNames => {\n  debug(`deleteFiles: files to delete: ${fileNames}`);\n  return Promise.all(fileNames.map(f => fs.unlink(f).catch((e) => {\n    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);\n  })));\n};\n\nmodule.exports = RollingFileWriteStream;\n"]},"metadata":{},"sourceType":"script"}