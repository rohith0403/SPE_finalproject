{"ast":null,"code":"const flatted = require('flatted');\n\nconst levels = require('./levels');\n/**\n * @name LoggingEvent\n * @namespace Log4js\n */\n\n\nclass LoggingEvent {\n  /**\n   * Models a logging event.\n   * @constructor\n   * @param {string} categoryName name of category\n   * @param {Log4js.Level} level level of message\n   * @param {Array} data objects to log\n   * @author Seth Chisamore\n   */\n  constructor(categoryName, level, data, context, location) {\n    this.startTime = new Date();\n    this.categoryName = categoryName;\n    this.data = data;\n    this.level = level;\n    this.context = Object.assign({}, context);\n    this.pid = process.pid;\n\n    if (location) {\n      this.functionName = location.functionName;\n      this.fileName = location.fileName;\n      this.lineNumber = location.lineNumber;\n      this.columnNumber = location.columnNumber;\n      this.callStack = location.callStack;\n    }\n  }\n\n  serialise() {\n    const logData = this.data.map(e => {\n      // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n      // The following allows us to serialize errors correctly.\n      if (e && e.message && e.stack) {\n        e = Object.assign({\n          message: e.message,\n          stack: e.stack\n        }, e);\n      }\n\n      return e;\n    });\n    this.data = logData;\n    return flatted.stringify(this);\n  }\n\n  static deserialise(serialised) {\n    let event;\n\n    try {\n      const rehydratedEvent = flatted.parse(serialised);\n      rehydratedEvent.data = rehydratedEvent.data.map(e => {\n        if (e && e.message && e.stack) {\n          const fakeError = new Error(e);\n          Object.keys(e).forEach(key => {\n            fakeError[key] = e[key];\n          });\n          e = fakeError;\n        }\n\n        return e;\n      });\n      event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context);\n      event.startTime = new Date(rehydratedEvent.startTime);\n      event.pid = rehydratedEvent.pid;\n      event.cluster = rehydratedEvent.cluster;\n    } catch (e) {\n      event = new LoggingEvent('log4js', levels.ERROR, ['Unable to parse log:', serialised, 'because: ', e]);\n    }\n\n    return event;\n  }\n\n}\n\nmodule.exports = LoggingEvent;","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/log4js/lib/LoggingEvent.js"],"names":["flatted","require","levels","LoggingEvent","constructor","categoryName","level","data","context","location","startTime","Date","Object","assign","pid","process","functionName","fileName","lineNumber","columnNumber","callStack","serialise","logData","map","e","message","stack","stringify","deserialise","serialised","event","rehydratedEvent","parse","fakeError","Error","keys","forEach","key","getLevel","levelStr","cluster","ERROR","module","exports"],"mappings":"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","sourcesContent":["const flatted = require('flatted');\nconst levels = require('./levels');\n\n/**\n * @name LoggingEvent\n * @namespace Log4js\n */\nclass LoggingEvent {\n  /**\n   * Models a logging event.\n   * @constructor\n   * @param {string} categoryName name of category\n   * @param {Log4js.Level} level level of message\n   * @param {Array} data objects to log\n   * @author Seth Chisamore\n   */\n  constructor(categoryName, level, data, context, location) {\n    this.startTime = new Date();\n    this.categoryName = categoryName;\n    this.data = data;\n    this.level = level;\n    this.context = Object.assign({}, context);\n    this.pid = process.pid;\n\n    if (location) {\n      this.functionName = location.functionName;\n      this.fileName = location.fileName;\n      this.lineNumber = location.lineNumber;\n      this.columnNumber = location.columnNumber;\n      this.callStack = location.callStack;\n    }\n  }\n\n  serialise() {\n    const logData = this.data.map((e) => {\n      // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n      // The following allows us to serialize errors correctly.\n      if (e && e.message && e.stack) {\n        e = Object.assign({ message: e.message, stack: e.stack }, e);\n      }\n      return e;\n    });\n    this.data = logData;\n    return flatted.stringify(this);\n  }\n\n  static deserialise(serialised) {\n    let event;\n    try {\n      const rehydratedEvent = flatted.parse(serialised);\n      rehydratedEvent.data = rehydratedEvent.data.map((e) => {\n        if (e && e.message && e.stack) {\n          const fakeError = new Error(e);\n          Object.keys(e).forEach((key) => { fakeError[key] = e[key]; });\n          e = fakeError;\n        }\n        return e;\n      });\n      event = new LoggingEvent(\n        rehydratedEvent.categoryName,\n        levels.getLevel(rehydratedEvent.level.levelStr),\n        rehydratedEvent.data,\n        rehydratedEvent.context\n      );\n      event.startTime = new Date(rehydratedEvent.startTime);\n      event.pid = rehydratedEvent.pid;\n      event.cluster = rehydratedEvent.cluster;\n    } catch (e) {\n      event = new LoggingEvent(\n        'log4js',\n        levels.ERROR,\n        ['Unable to parse log:', serialised, 'because: ', e]\n      );\n    }\n\n    return event;\n  }\n}\n\nmodule.exports = LoggingEvent;\n"]},"metadata":{},"sourceType":"script"}