{"ast":null,"code":"const configuration = require('./configuration');\n\nconst validColours = ['white', 'grey', 'black', 'blue', 'cyan', 'green', 'magenta', 'red', 'yellow'];\n\nclass Level {\n  constructor(level, levelStr, colour) {\n    this.level = level;\n    this.levelStr = levelStr;\n    this.colour = colour;\n  }\n\n  toString() {\n    return this.levelStr;\n  }\n  /**\n   * converts given String to corresponding Level\n   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level\n   * @param {Level} [defaultLevel] -- default Level, if no String representation\n   * @return {Level}\n   */\n\n\n  static getLevel(sArg, defaultLevel) {\n    if (!sArg) {\n      return defaultLevel;\n    }\n\n    if (sArg instanceof Level) {\n      return sArg;\n    } // a json-serialised level won't be an instance of Level (see issue #768)\n\n\n    if (sArg instanceof Object && sArg.levelStr) {\n      sArg = sArg.levelStr;\n    }\n\n    return Level[sArg.toString().toUpperCase()] || defaultLevel;\n  }\n\n  static addLevels(customLevels) {\n    if (customLevels) {\n      const levels = Object.keys(customLevels);\n      levels.forEach(l => {\n        const levelStr = l.toUpperCase();\n        Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);\n        const existingLevelIndex = Level.levels.findIndex(lvl => lvl.levelStr === levelStr);\n\n        if (existingLevelIndex > -1) {\n          Level.levels[existingLevelIndex] = Level[levelStr];\n        } else {\n          Level.levels.push(Level[levelStr]);\n        }\n      });\n      Level.levels.sort((a, b) => a.level - b.level);\n    }\n  }\n\n  isLessThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n\n    return this.level <= otherLevel.level;\n  }\n\n  isGreaterThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n\n    return this.level >= otherLevel.level;\n  }\n\n  isEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n\n    return this.level === otherLevel.level;\n  }\n\n}\n\nLevel.levels = [];\nLevel.addLevels({\n  ALL: {\n    value: Number.MIN_VALUE,\n    colour: 'grey'\n  },\n  TRACE: {\n    value: 5000,\n    colour: 'blue'\n  },\n  DEBUG: {\n    value: 10000,\n    colour: 'cyan'\n  },\n  INFO: {\n    value: 20000,\n    colour: 'green'\n  },\n  WARN: {\n    value: 30000,\n    colour: 'yellow'\n  },\n  ERROR: {\n    value: 40000,\n    colour: 'red'\n  },\n  FATAL: {\n    value: 50000,\n    colour: 'magenta'\n  },\n  MARK: {\n    value: 9007199254740992,\n    colour: 'grey'\n  },\n  // 2^53\n  OFF: {\n    value: Number.MAX_VALUE,\n    colour: 'grey'\n  }\n});\nconfiguration.addListener(config => {\n  const levelConfig = config.levels;\n\n  if (levelConfig) {\n    configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig)), 'levels must be an object');\n    const newLevels = Object.keys(levelConfig);\n    newLevels.forEach(l => {\n      configuration.throwExceptionIf(config, configuration.not(configuration.validIdentifier(l)), `level name \"${l}\" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);\n      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig[l])), `level \"${l}\" must be an object`);\n      configuration.throwExceptionIf(config, configuration.not(levelConfig[l].value), `level \"${l}\" must have a 'value' property`);\n      configuration.throwExceptionIf(config, configuration.not(configuration.anInteger(levelConfig[l].value)), `level \"${l}\".value must have an integer value`);\n      configuration.throwExceptionIf(config, configuration.not(levelConfig[l].colour), `level \"${l}\" must have a 'colour' property`);\n      configuration.throwExceptionIf(config, configuration.not(validColours.indexOf(levelConfig[l].colour) > -1), `level \"${l}\".colour must be one of ${validColours.join(', ')}`);\n    });\n  }\n});\nconfiguration.addListener(config => {\n  Level.addLevels(config.levels);\n});\nmodule.exports = Level;","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/log4js/lib/levels.js"],"names":["configuration","require","validColours","Level","constructor","level","levelStr","colour","toString","getLevel","sArg","defaultLevel","Object","toUpperCase","addLevels","customLevels","levels","keys","forEach","l","value","existingLevelIndex","findIndex","lvl","push","sort","a","b","isLessThanOrEqualTo","otherLevel","isGreaterThanOrEqualTo","isEqualTo","ALL","Number","MIN_VALUE","TRACE","DEBUG","INFO","WARN","ERROR","FATAL","MARK","OFF","MAX_VALUE","addListener","config","levelConfig","throwExceptionIf","not","anObject","newLevels","validIdentifier","anInteger","indexOf","join","module","exports"],"mappings":"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","sourcesContent":["\n\nconst configuration = require('./configuration');\n\nconst validColours = [\n  'white', 'grey', 'black',\n  'blue', 'cyan', 'green',\n  'magenta', 'red', 'yellow'\n];\n\nclass Level {\n  constructor(level, levelStr, colour) {\n    this.level = level;\n    this.levelStr = levelStr;\n    this.colour = colour;\n  }\n\n  toString() {\n    return this.levelStr;\n  }\n\n  /**\n   * converts given String to corresponding Level\n   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level\n   * @param {Level} [defaultLevel] -- default Level, if no String representation\n   * @return {Level}\n   */\n  static getLevel(sArg, defaultLevel) {\n    if (!sArg) {\n      return defaultLevel;\n    }\n\n    if (sArg instanceof Level) {\n      return sArg;\n    }\n\n    // a json-serialised level won't be an instance of Level (see issue #768)\n    if (sArg instanceof Object && sArg.levelStr) {\n      sArg = sArg.levelStr;\n    }\n\n    return Level[sArg.toString().toUpperCase()] || defaultLevel;\n  }\n\n  static addLevels(customLevels) {\n    if (customLevels) {\n      const levels = Object.keys(customLevels);\n      levels.forEach((l) => {\n        const levelStr = l.toUpperCase();\n        Level[levelStr] = new Level(\n          customLevels[l].value,\n          levelStr,\n          customLevels[l].colour\n        );\n        const existingLevelIndex = Level.levels.findIndex(lvl => lvl.levelStr === levelStr);\n        if (existingLevelIndex > -1) {\n          Level.levels[existingLevelIndex] = Level[levelStr];\n        } else {\n          Level.levels.push(Level[levelStr]);\n        }\n      });\n      Level.levels.sort((a, b) => a.level - b.level);\n    }\n  }\n\n\n  isLessThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level <= otherLevel.level;\n  }\n\n  isGreaterThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level >= otherLevel.level;\n  }\n\n  isEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level === otherLevel.level;\n  }\n}\n\nLevel.levels = [];\nLevel.addLevels({\n  ALL: { value: Number.MIN_VALUE, colour: 'grey' },\n  TRACE: { value: 5000, colour: 'blue' },\n  DEBUG: { value: 10000, colour: 'cyan' },\n  INFO: { value: 20000, colour: 'green' },\n  WARN: { value: 30000, colour: 'yellow' },\n  ERROR: { value: 40000, colour: 'red' },\n  FATAL: { value: 50000, colour: 'magenta' },\n  MARK: { value: 9007199254740992, colour: 'grey' }, // 2^53\n  OFF: { value: Number.MAX_VALUE, colour: 'grey' }\n});\n\nconfiguration.addListener((config) => {\n  const levelConfig = config.levels;\n  if (levelConfig) {\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(configuration.anObject(levelConfig)),\n      'levels must be an object'\n    );\n    const newLevels = Object.keys(levelConfig);\n    newLevels.forEach((l) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.validIdentifier(l)),\n        `level name \"${l}\" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.anObject(levelConfig[l])),\n        `level \"${l}\" must be an object`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(levelConfig[l].value),\n        `level \"${l}\" must have a 'value' property`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.anInteger(levelConfig[l].value)),\n        `level \"${l}\".value must have an integer value`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(levelConfig[l].colour),\n        `level \"${l}\" must have a 'colour' property`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(validColours.indexOf(levelConfig[l].colour) > -1),\n        `level \"${l}\".colour must be one of ${validColours.join(', ')}`\n      );\n    });\n  }\n});\n\nconfiguration.addListener((config) => {\n  Level.addLevels(config.levels);\n});\n\nmodule.exports = Level;\n"]},"metadata":{},"sourceType":"script"}