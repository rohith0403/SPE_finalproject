{"ast":null,"code":"const debug = require('debug')('log4js:categories');\n\nconst configuration = require('./configuration');\n\nconst levels = require('./levels');\n\nconst appenders = require('./appenders');\n\nconst categories = new Map();\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\n\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n\n  const parentCategoryName = categoryName.substring(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = {\n      inherit: true,\n      appenders: []\n    };\n  } // make sure parent has had its inheritance taken care of before pulling its properties to this child\n\n\n  inheritFromParent(config, parentCategory, parentCategoryName); // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n\n  if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level; // merge in appenders from parent (parent is already holding its inherited appenders)\n\n  parentCategory.appenders.forEach(ap => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\n\n\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(name => {\n    const category = config.categories[name]; // add inherited appenders and level to this category\n\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener(config => addCategoryInheritance(config));\nconfiguration.addListener(config => {\n  configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property \"categories\" of type object.');\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(config, configuration.not(categoryNames.length), 'must define at least one category.');\n  categoryNames.forEach(name => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(config, [configuration.not(category.appenders), configuration.not(category.level)], `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`);\n    configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), `category \"${name}\" is not valid (appenders must be an array of appender names)`);\n    configuration.throwExceptionIf(config, configuration.not(category.appenders.length), `category \"${name}\" is not valid (appenders must contain at least one appender name)`);\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(config, typeof category.enableCallStack !== 'boolean', `category \"${name}\" is not valid (enableCallStack must be boolean type)`);\n    }\n\n    category.appenders.forEach(appender => {\n      configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`);\n    });\n    configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), `category \"${name}\" is not valid (level \"${category.level}\" not recognised;` + ` valid levels are ${levels.levels.join(', ')})`);\n  });\n  configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a \"default\" category.');\n});\n\nconst setup = config => {\n  categories.clear();\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(name => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach(appender => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(name, {\n        appenders: categoryAppenders,\n        level: levels.getLevel(category.level),\n        enableCallStack: category.enableCallStack || false\n      });\n    });\n  });\n};\n\nsetup({\n  categories: {\n    default: {\n      appenders: ['out'],\n      level: 'OFF'\n    }\n  }\n});\nconfiguration.addListener(setup);\n\nconst configForCategory = category => {\n  debug(`configForCategory: searching for config for ${category}`);\n\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, searching for parents`);\n    return configForCategory(category.substring(0, category.lastIndexOf('.')));\n  }\n\n  debug('configForCategory: returning config for default category');\n  return configForCategory('default');\n};\n\nconst appendersForCategory = category => configForCategory(category).appenders;\n\nconst getLevelForCategory = category => configForCategory(category).level;\n\nconst setLevelForCategory = (category, level) => {\n  let categoryConfig = categories.get(category);\n  debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);\n\n  if (!categoryConfig) {\n    const sourceCategoryConfig = configForCategory(category);\n    debug('setLevelForCategory: no config found for category, ' + `found ${sourceCategoryConfig} for parents of ${category}`);\n    categoryConfig = {\n      appenders: sourceCategoryConfig.appenders\n    };\n  }\n\n  categoryConfig.level = level;\n  categories.set(category, categoryConfig);\n};\n\nconst getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;\n\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory\n};","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/log4js/lib/categories.js"],"names":["debug","require","configuration","levels","appenders","categories","Map","inheritFromParent","config","category","categoryName","inherit","lastDotIndex","lastIndexOf","parentCategoryName","substring","parentCategory","length","level","forEach","ap","includes","push","parent","addCategoryInheritance","categoryNames","Object","keys","name","addPreProcessingListener","addListener","throwExceptionIf","not","anObject","Array","isArray","prototype","hasOwnProperty","call","enableCallStack","appender","get","getLevel","join","default","setup","clear","categoryAppenders","set","configForCategory","has","indexOf","appendersForCategory","getLevelForCategory","setLevelForCategory","categoryConfig","sourceCategoryConfig","getEnableCallStackForCategory","setEnableCallStackForCategory","useCallStack","module","exports"],"mappings":"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","sourcesContent":["const debug = require('debug')('log4js:categories');\nconst configuration = require('./configuration');\nconst levels = require('./levels');\nconst appenders = require('./appenders');\n\nconst categories = new Map();\n\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n  const parentCategoryName = categoryName.substring(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = { inherit: true, appenders: [] };\n  }\n\n  // make sure parent has had its inheritance taken care of before pulling its properties to this child\n  inheritFromParent(config, parentCategory, parentCategoryName);\n\n  // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n  if (!config.categories[parentCategoryName]\n    && parentCategory.appenders\n    && parentCategory.appenders.length\n    && parentCategory.level) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level;\n\n  // merge in appenders from parent (parent is already holding its inherited appenders)\n  parentCategory.appenders.forEach((ap) => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n\n\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    // add inherited appenders and level to this category\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener(config => addCategoryInheritance(config));\n\nconfiguration.addListener((config) => {\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(configuration.anObject(config.categories)),\n    'must have a property \"categories\" of type object.'\n  );\n\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(categoryNames.length),\n    'must define at least one category.'\n  );\n\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(\n      config,\n      [\n        configuration.not(category.appenders),\n        configuration.not(category.level)\n      ],\n      `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(Array.isArray(category.appenders)),\n      `category \"${name}\" is not valid (appenders must be an array of appender names)`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(category.appenders.length),\n      `category \"${name}\" is not valid (appenders must contain at least one appender name)`\n    );\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(\n        config,\n        typeof category.enableCallStack !== 'boolean',\n        `category \"${name}\" is not valid (enableCallStack must be boolean type)`\n      );\n    }\n\n    category.appenders.forEach((appender) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(appenders.get(appender)),\n        `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`\n      );\n    });\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(levels.getLevel(category.level)),\n      `category \"${name}\" is not valid (level \"${category.level}\" not recognised;`\n      + ` valid levels are ${levels.levels.join(', ')})`\n    );\n  });\n\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(config.categories.default),\n    'must define a \"default\" category.'\n  );\n});\n\nconst setup = (config) => {\n  categories.clear();\n\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach((appender) => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(\n        name,\n        {\n          appenders: categoryAppenders,\n          level: levels.getLevel(category.level),\n          enableCallStack: category.enableCallStack || false\n        }\n      );\n    });\n  });\n};\n\nsetup({ categories: { default: { appenders: ['out'], level: 'OFF' } } });\nconfiguration.addListener(setup);\n\nconst configForCategory = (category) => {\n  debug(`configForCategory: searching for config for ${category}`);\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, searching for parents`);\n    return configForCategory(category.substring(0, category.lastIndexOf('.')));\n  }\n  debug('configForCategory: returning config for default category');\n  return configForCategory('default');\n};\n\nconst appendersForCategory = category => configForCategory(category).appenders;\nconst getLevelForCategory = category => configForCategory(category).level;\n\nconst setLevelForCategory = (category, level) => {\n  let categoryConfig = categories.get(category);\n  debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);\n  if (!categoryConfig) {\n    const sourceCategoryConfig = configForCategory(category);\n    debug('setLevelForCategory: no config found for category, '\n      + `found ${sourceCategoryConfig} for parents of ${category}`);\n    categoryConfig = { appenders: sourceCategoryConfig.appenders };\n  }\n  categoryConfig.level = level;\n  categories.set(category, categoryConfig);\n};\n\nconst getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory,\n};\n"]},"metadata":{},"sourceType":"script"}