{"ast":null,"code":"const debug = require(\"debug\")(\"streamroller:fileNameParser\");\n\nconst FILENAME_SEP = \".\";\nconst ZIP_EXT = \".gz\";\n\nconst format = require(\"date-format\");\n\nmodule.exports = ({\n  file,\n  keepFileExt,\n  pattern\n}) => {\n  // All these functions take two arguments: f, the filename, and p, the result placeholder\n  // They return the filename with any matching parts removed.\n  // The \"zip\" function, for instance, removes the \".gz\" part of the filename (if present)\n  const zip = (f, p) => {\n    if (f.endsWith(ZIP_EXT)) {\n      debug(\"it is gzipped\");\n      p.isCompressed = true;\n      return f.slice(0, -1 * ZIP_EXT.length);\n    }\n\n    return f;\n  };\n\n  const __NOT_MATCHING__ = \"__NOT_MATCHING__\";\n\n  const extAtEnd = f => {\n    if (f.startsWith(file.name) && f.endsWith(file.ext)) {\n      debug(\"it starts and ends with the right things\");\n      return f.slice(file.name.length + 1, -1 * file.ext.length);\n    }\n\n    return __NOT_MATCHING__;\n  };\n\n  const extInMiddle = f => {\n    if (f.startsWith(file.base)) {\n      debug(\"it starts with the right things\");\n      return f.slice(file.base.length + 1);\n    }\n\n    return __NOT_MATCHING__;\n  };\n\n  const dateAndIndex = (f, p) => {\n    const items = f.split(FILENAME_SEP);\n    let indexStr = items[items.length - 1];\n    debug(\"items: \", items, \", indexStr: \", indexStr);\n    let dateStr = f;\n\n    if (indexStr !== undefined && indexStr.match(/^\\d+$/)) {\n      dateStr = f.slice(0, -1 * (indexStr.length + 1));\n      debug(`dateStr is ${dateStr}`);\n\n      if (pattern && !dateStr) {\n        dateStr = indexStr;\n        indexStr = \"0\";\n      }\n    } else {\n      indexStr = \"0\";\n    }\n\n    try {\n      // Two arguments for new Date() are intentional. This will set other date\n      // components to minimal values in the current timezone instead of UTC,\n      // as new Date(0) will do.\n      const date = format.parse(pattern, dateStr, new Date(0, 0));\n      if (format.asString(pattern, date) !== dateStr) return f;\n      p.index = parseInt(indexStr, 10);\n      p.date = dateStr;\n      p.timestamp = date.getTime();\n      return \"\";\n    } catch (e) {\n      //not a valid date, don't panic.\n      debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);\n      return f;\n    }\n  };\n\n  const index = (f, p) => {\n    if (f.match(/^\\d+$/)) {\n      debug(\"it has an index\");\n      p.index = parseInt(f, 10);\n      return \"\";\n    }\n\n    return f;\n  };\n\n  let parts = [zip, keepFileExt ? extAtEnd : extInMiddle, pattern ? dateAndIndex : index];\n  return filename => {\n    let result = {\n      filename,\n      index: 0,\n      isCompressed: false\n    }; // pass the filename through each of the file part parsers\n\n    let whatsLeftOver = parts.reduce((remains, part) => part(remains, result), filename); // if there's anything left after parsing, then it wasn't a valid filename\n\n    return whatsLeftOver ? null : result;\n  };\n};","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/streamroller/lib/fileNameParser.js"],"names":["debug","require","FILENAME_SEP","ZIP_EXT","format","module","exports","file","keepFileExt","pattern","zip","f","p","endsWith","isCompressed","slice","length","__NOT_MATCHING__","extAtEnd","startsWith","name","ext","extInMiddle","base","dateAndIndex","items","split","indexStr","dateStr","undefined","match","date","parse","Date","asString","index","parseInt","timestamp","getTime","e","parts","filename","result","whatsLeftOver","reduce","remains","part"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"streamroller:fileNameParser\");\nconst FILENAME_SEP = \".\";\nconst ZIP_EXT = \".gz\";\nconst format = require(\"date-format\");\n\nmodule.exports = ({ file, keepFileExt, pattern }) => {\n  // All these functions take two arguments: f, the filename, and p, the result placeholder\n  // They return the filename with any matching parts removed.\n  // The \"zip\" function, for instance, removes the \".gz\" part of the filename (if present)\n  const zip = (f, p) => {\n    if (f.endsWith(ZIP_EXT)) {\n      debug(\"it is gzipped\");\n      p.isCompressed = true;\n      return f.slice(0, -1 * ZIP_EXT.length);\n    }\n    return f;\n  };\n\n  const __NOT_MATCHING__ = \"__NOT_MATCHING__\";\n\n  const extAtEnd = f => {\n    if (f.startsWith(file.name) && f.endsWith(file.ext)) {\n      debug(\"it starts and ends with the right things\");\n      return f.slice(file.name.length + 1, -1 * file.ext.length);\n    }\n    return __NOT_MATCHING__;\n  };\n\n  const extInMiddle = f => {\n    if (f.startsWith(file.base)) {\n      debug(\"it starts with the right things\");\n      return f.slice(file.base.length + 1);\n    }\n    return __NOT_MATCHING__;\n  };\n\n  const dateAndIndex = (f, p) => {\n    const items = f.split(FILENAME_SEP);\n    let indexStr = items[items.length - 1];\n    debug(\"items: \", items, \", indexStr: \", indexStr);\n    let dateStr = f;\n    if (indexStr !== undefined && indexStr.match(/^\\d+$/)) {\n      dateStr = f.slice(0, -1 * (indexStr.length + 1));\n      debug(`dateStr is ${dateStr}`);\n      if (pattern && !dateStr) {\n        dateStr = indexStr;\n        indexStr = \"0\";\n      }\n    } else {\n      indexStr = \"0\";\n    }\n\n    try {\n      // Two arguments for new Date() are intentional. This will set other date\n      // components to minimal values in the current timezone instead of UTC,\n      // as new Date(0) will do.\n      const date = format.parse(pattern, dateStr, new Date(0, 0));\n      if (format.asString(pattern, date) !== dateStr) return f;\n      p.index = parseInt(indexStr, 10);\n      p.date = dateStr;\n      p.timestamp = date.getTime();\n      return \"\";\n    } catch (e) {\n      //not a valid date, don't panic.\n      debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);\n      return f;\n    }\n  };\n\n  const index = (f, p) => {\n    if (f.match(/^\\d+$/)) {\n      debug(\"it has an index\");\n      p.index = parseInt(f, 10);\n      return \"\";\n    }\n    return f;\n  };\n\n  let parts = [\n    zip,\n    keepFileExt ? extAtEnd : extInMiddle,\n    pattern ? dateAndIndex : index\n  ];\n\n  return filename => {\n    let result = { filename, index: 0, isCompressed: false };\n    // pass the filename through each of the file part parsers\n    let whatsLeftOver = parts.reduce(\n      (remains, part) => part(remains, result),\n      filename\n    );\n    // if there's anything left after parsing, then it wasn't a valid filename\n    return whatsLeftOver ? null : result;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}