{"ast":null,"code":"const dateFormat = require('date-format');\n\nconst os = require('os');\n\nconst util = require('util');\n\nconst path = require('path');\n\nconst styles = {\n  // styles\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  // grayscale\n  white: [37, 39],\n  grey: [90, 39],\n  black: [90, 39],\n  // colors\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [91, 39],\n  yellow: [33, 39]\n};\n\nfunction colorizeStart(style) {\n  return style ? `\\x1B[${styles[style][0]}m` : '';\n}\n\nfunction colorizeEnd(style) {\n  return style ? `\\x1B[${styles[style][1]}m` : '';\n}\n/**\n * Taken from masylum's fork (https://github.com/masylum/log4js-node)\n */\n\n\nfunction colorize(str, style) {\n  return colorizeStart(style) + str + colorizeEnd(style);\n}\n\nfunction timestampLevelAndCategory(loggingEvent, colour) {\n  return colorize(util.format('[%s] [%s] %s - ', dateFormat.asString(loggingEvent.startTime), loggingEvent.level.toString(), loggingEvent.categoryName), colour);\n}\n/**\n * BasicLayout is a simple layout for storing the logs. The logs are stored\n * in following format:\n * <pre>\n * [startTime] [logLevel] categoryName - message\\n\n * </pre>\n *\n * @author Stephan Strittmatter\n */\n\n\nfunction basicLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent) + util.format(...loggingEvent.data);\n}\n/**\n * colouredLayout - taken from masylum's fork.\n * same as basicLayout, but with colours.\n */\n\n\nfunction colouredLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util.format(...loggingEvent.data);\n}\n\nfunction messagePassThroughLayout(loggingEvent) {\n  return util.format(...loggingEvent.data);\n}\n\nfunction dummyLayout(loggingEvent) {\n  return loggingEvent.data[0];\n}\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * both padding and truncation can be negative.\n * Negative truncation = trunc from end of string\n * Positive truncation = trunc from start of string\n * Negative padding = pad right\n * Positive padding = pad left\n *\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %h hostname\n *  - %m log data\n *  - %d date in constious formats\n *  - %% %\n *  - %n newline\n *  - %z pid\n *  - %f filename\n *  - %l line number\n *  - %o column postion\n *  - %s call stack\n *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n *  - %X{<tokenname>} add dynamic tokens to your log. Tokens are specified in logger context\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects.\n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { 'pid' : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layout function.\n * @return {Function}\n * @param pattern\n * @param tokens\n * @param timezoneOffset\n *\n * @authors ['Stephan Strittmatter', 'Jan Schmidle']\n */\n\n\nfunction patternLayout(pattern, tokens) {\n  const TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';\n  const regex = /%(-?[0-9]+)?(\\.?-?[0-9]+)?([[\\]cdhmnprzxXyflos%])(\\{([^}]+)\\})?|([^%]+)/;\n  pattern = pattern || TTCC_CONVERSION_PATTERN;\n\n  function categoryName(loggingEvent, specifier) {\n    let loggerName = loggingEvent.categoryName;\n\n    if (specifier) {\n      const precision = parseInt(specifier, 10);\n      const loggerNameBits = loggerName.split('.');\n\n      if (precision < loggerNameBits.length) {\n        loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join('.');\n      }\n    }\n\n    return loggerName;\n  }\n\n  function formatAsDate(loggingEvent, specifier) {\n    let format = dateFormat.ISO8601_FORMAT;\n\n    if (specifier) {\n      format = specifier; // Pick up special cases\n\n      if (format === 'ISO8601') {\n        format = dateFormat.ISO8601_FORMAT;\n      } else if (format === 'ISO8601_WITH_TZ_OFFSET') {\n        format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;\n      } else if (format === 'ABSOLUTE') {\n        format = dateFormat.ABSOLUTETIME_FORMAT;\n      } else if (format === 'DATE') {\n        format = dateFormat.DATETIME_FORMAT;\n      }\n    } // Format the date\n\n\n    return dateFormat.asString(format, loggingEvent.startTime);\n  }\n\n  function hostname() {\n    return os.hostname().toString();\n  }\n\n  function formatMessage(loggingEvent) {\n    return util.format(...loggingEvent.data);\n  }\n\n  function endOfLine() {\n    return os.EOL;\n  }\n\n  function logLevel(loggingEvent) {\n    return loggingEvent.level.toString();\n  }\n\n  function startTime(loggingEvent) {\n    return dateFormat.asString('hh:mm:ss', loggingEvent.startTime);\n  }\n\n  function startColour(loggingEvent) {\n    return colorizeStart(loggingEvent.level.colour);\n  }\n\n  function endColour(loggingEvent) {\n    return colorizeEnd(loggingEvent.level.colour);\n  }\n\n  function percent() {\n    return '%';\n  }\n\n  function pid(loggingEvent) {\n    return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();\n  }\n\n  function clusterInfo() {\n    // this used to try to return the master and worker pids,\n    // but it would never have worked because master pid is not available to workers\n    // leaving this here to maintain compatibility for patterns\n    return pid();\n  }\n\n  function userDefined(loggingEvent, specifier) {\n    if (typeof tokens[specifier] !== 'undefined') {\n      return typeof tokens[specifier] === 'function' ? tokens[specifier](loggingEvent) : tokens[specifier];\n    }\n\n    return null;\n  }\n\n  function contextDefined(loggingEvent, specifier) {\n    const resolver = loggingEvent.context[specifier];\n\n    if (typeof resolver !== 'undefined') {\n      return typeof resolver === 'function' ? resolver(loggingEvent) : resolver;\n    }\n\n    return null;\n  }\n\n  function fileName(loggingEvent, specifier) {\n    let filename = loggingEvent.fileName || '';\n\n    if (specifier) {\n      const fileDepth = parseInt(specifier, 10);\n      const fileList = filename.split(path.sep);\n\n      if (fileList.length > fileDepth) {\n        filename = fileList.slice(-fileDepth).join(path.sep);\n      }\n    }\n\n    return filename;\n  }\n\n  function lineNumber(loggingEvent) {\n    return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : '';\n  }\n\n  function columnNumber(loggingEvent) {\n    return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : '';\n  }\n\n  function callStack(loggingEvent) {\n    return loggingEvent.callStack || '';\n  }\n  /* eslint quote-props:0 */\n\n\n  const replacers = {\n    c: categoryName,\n    d: formatAsDate,\n    h: hostname,\n    m: formatMessage,\n    n: endOfLine,\n    p: logLevel,\n    r: startTime,\n    '[': startColour,\n    ']': endColour,\n    y: clusterInfo,\n    z: pid,\n    '%': percent,\n    x: userDefined,\n    X: contextDefined,\n    f: fileName,\n    l: lineNumber,\n    o: columnNumber,\n    s: callStack\n  };\n\n  function replaceToken(conversionCharacter, loggingEvent, specifier) {\n    return replacers[conversionCharacter](loggingEvent, specifier);\n  }\n\n  function truncate(truncation, toTruncate) {\n    let len;\n\n    if (truncation) {\n      len = parseInt(truncation.substr(1), 10); // negative truncate length means truncate from end of string\n\n      return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);\n    }\n\n    return toTruncate;\n  }\n\n  function pad(padding, toPad) {\n    let len;\n\n    if (padding) {\n      if (padding.charAt(0) === '-') {\n        len = parseInt(padding.substr(1), 10); // Right pad with spaces\n\n        while (toPad.length < len) {\n          toPad += ' ';\n        }\n      } else {\n        len = parseInt(padding, 10); // Left pad with spaces\n\n        while (toPad.length < len) {\n          toPad = ` ${toPad}`;\n        }\n      }\n    }\n\n    return toPad;\n  }\n\n  function truncateAndPad(toTruncAndPad, truncation, padding) {\n    let replacement = toTruncAndPad;\n    replacement = truncate(truncation, replacement);\n    replacement = pad(padding, replacement);\n    return replacement;\n  }\n\n  return function (loggingEvent) {\n    let formattedString = '';\n    let result;\n    let searchString = pattern;\n    /* eslint no-cond-assign:0 */\n\n    while ((result = regex.exec(searchString)) !== null) {\n      // const matchedString = result[0];\n      const padding = result[1];\n      const truncation = result[2];\n      const conversionCharacter = result[3];\n      const specifier = result[5];\n      const text = result[6]; // Check if the pattern matched was just normal text\n\n      if (text) {\n        formattedString += text.toString();\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);\n        formattedString += truncateAndPad(replacement, truncation, padding);\n      }\n\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n\n    return formattedString;\n  };\n}\n\nconst layoutMakers = {\n  messagePassThrough() {\n    return messagePassThroughLayout;\n  },\n\n  basic() {\n    return basicLayout;\n  },\n\n  colored() {\n    return colouredLayout;\n  },\n\n  coloured() {\n    return colouredLayout;\n  },\n\n  pattern(config) {\n    return patternLayout(config && config.pattern, config && config.tokens);\n  },\n\n  dummy() {\n    return dummyLayout;\n  }\n\n};\nmodule.exports = {\n  basicLayout,\n  messagePassThroughLayout,\n  patternLayout,\n  colouredLayout,\n  coloredLayout: colouredLayout,\n  dummyLayout,\n\n  addLayout(name, serializerGenerator) {\n    layoutMakers[name] = serializerGenerator;\n  },\n\n  layout(name, config) {\n    return layoutMakers[name] && layoutMakers[name](config);\n  }\n\n};","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/log4js/lib/layouts.js"],"names":["dateFormat","require","os","util","path","styles","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","colorizeStart","style","colorizeEnd","colorize","str","timestampLevelAndCategory","loggingEvent","colour","format","asString","startTime","level","toString","categoryName","basicLayout","data","colouredLayout","messagePassThroughLayout","dummyLayout","patternLayout","pattern","tokens","TTCC_CONVERSION_PATTERN","regex","specifier","loggerName","precision","parseInt","loggerNameBits","split","length","slice","join","formatAsDate","ISO8601_FORMAT","ISO8601_WITH_TZ_OFFSET_FORMAT","ABSOLUTETIME_FORMAT","DATETIME_FORMAT","hostname","formatMessage","endOfLine","EOL","logLevel","startColour","endColour","percent","pid","process","clusterInfo","userDefined","contextDefined","resolver","context","fileName","filename","fileDepth","fileList","sep","lineNumber","columnNumber","callStack","replacers","c","d","h","m","n","p","r","y","z","x","X","f","l","o","s","replaceToken","conversionCharacter","truncate","truncation","toTruncate","len","substr","pad","padding","toPad","charAt","truncateAndPad","toTruncAndPad","replacement","formattedString","result","searchString","exec","text","index","layoutMakers","messagePassThrough","basic","colored","coloured","config","dummy","module","exports","coloredLayout","addLayout","name","serializerGenerator","layout"],"mappings":"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","sourcesContent":["const dateFormat = require('date-format');\nconst os = require('os');\nconst util = require('util');\nconst path = require('path');\n\nconst styles = {\n  // styles\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  // grayscale\n  white: [37, 39],\n  grey: [90, 39],\n  black: [90, 39],\n  // colors\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [91, 39],\n  yellow: [33, 39]\n};\n\nfunction colorizeStart(style) {\n  return style ? `\\x1B[${styles[style][0]}m` : '';\n}\n\nfunction colorizeEnd(style) {\n  return style ? `\\x1B[${styles[style][1]}m` : '';\n}\n\n/**\n * Taken from masylum's fork (https://github.com/masylum/log4js-node)\n */\nfunction colorize(str, style) {\n  return colorizeStart(style) + str + colorizeEnd(style);\n}\n\nfunction timestampLevelAndCategory(loggingEvent, colour) {\n  return colorize(\n    util.format(\n      '[%s] [%s] %s - ',\n      dateFormat.asString(loggingEvent.startTime),\n      loggingEvent.level.toString(),\n      loggingEvent.categoryName\n    ),\n    colour\n  );\n}\n\n/**\n * BasicLayout is a simple layout for storing the logs. The logs are stored\n * in following format:\n * <pre>\n * [startTime] [logLevel] categoryName - message\\n\n * </pre>\n *\n * @author Stephan Strittmatter\n */\nfunction basicLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent) + util.format(...loggingEvent.data);\n}\n\n/**\n * colouredLayout - taken from masylum's fork.\n * same as basicLayout, but with colours.\n */\nfunction colouredLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util.format(...loggingEvent.data);\n}\n\nfunction messagePassThroughLayout(loggingEvent) {\n  return util.format(...loggingEvent.data);\n}\n\nfunction dummyLayout(loggingEvent) {\n  return loggingEvent.data[0];\n}\n\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * both padding and truncation can be negative.\n * Negative truncation = trunc from end of string\n * Positive truncation = trunc from start of string\n * Negative padding = pad right\n * Positive padding = pad left\n *\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %h hostname\n *  - %m log data\n *  - %d date in constious formats\n *  - %% %\n *  - %n newline\n *  - %z pid\n *  - %f filename\n *  - %l line number\n *  - %o column postion\n *  - %s call stack\n *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n *  - %X{<tokenname>} add dynamic tokens to your log. Tokens are specified in logger context\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects.\n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { 'pid' : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layout function.\n * @return {Function}\n * @param pattern\n * @param tokens\n * @param timezoneOffset\n *\n * @authors ['Stephan Strittmatter', 'Jan Schmidle']\n */\nfunction patternLayout(pattern, tokens) {\n  const TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';\n  const regex = /%(-?[0-9]+)?(\\.?-?[0-9]+)?([[\\]cdhmnprzxXyflos%])(\\{([^}]+)\\})?|([^%]+)/;\n\n  pattern = pattern || TTCC_CONVERSION_PATTERN;\n\n  function categoryName(loggingEvent, specifier) {\n    let loggerName = loggingEvent.categoryName;\n    if (specifier) {\n      const precision = parseInt(specifier, 10);\n      const loggerNameBits = loggerName.split('.');\n      if (precision < loggerNameBits.length) {\n        loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join('.');\n      }\n    }\n    return loggerName;\n  }\n\n  function formatAsDate(loggingEvent, specifier) {\n    let format = dateFormat.ISO8601_FORMAT;\n    if (specifier) {\n      format = specifier;\n      // Pick up special cases\n      if (format === 'ISO8601') {\n        format = dateFormat.ISO8601_FORMAT;\n      } else if (format === 'ISO8601_WITH_TZ_OFFSET') {\n        format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;\n      } else if (format === 'ABSOLUTE') {\n        format = dateFormat.ABSOLUTETIME_FORMAT;\n      } else if (format === 'DATE') {\n        format = dateFormat.DATETIME_FORMAT;\n      }\n    }\n    // Format the date\n    return dateFormat.asString(format, loggingEvent.startTime);\n  }\n\n  function hostname() {\n    return os.hostname().toString();\n  }\n\n  function formatMessage(loggingEvent) {\n    return util.format(...loggingEvent.data);\n  }\n\n  function endOfLine() {\n    return os.EOL;\n  }\n\n  function logLevel(loggingEvent) {\n    return loggingEvent.level.toString();\n  }\n\n  function startTime(loggingEvent) {\n    return dateFormat.asString('hh:mm:ss', loggingEvent.startTime);\n  }\n\n  function startColour(loggingEvent) {\n    return colorizeStart(loggingEvent.level.colour);\n  }\n\n  function endColour(loggingEvent) {\n    return colorizeEnd(loggingEvent.level.colour);\n  }\n\n  function percent() {\n    return '%';\n  }\n\n  function pid(loggingEvent) {\n    return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();\n  }\n\n  function clusterInfo() {\n    // this used to try to return the master and worker pids,\n    // but it would never have worked because master pid is not available to workers\n    // leaving this here to maintain compatibility for patterns\n    return pid();\n  }\n\n  function userDefined(loggingEvent, specifier) {\n    if (typeof tokens[specifier] !== 'undefined') {\n      return typeof tokens[specifier] === 'function' ? tokens[specifier](loggingEvent) : tokens[specifier];\n    }\n\n    return null;\n  }\n\n  function contextDefined(loggingEvent, specifier) {\n    const resolver = loggingEvent.context[specifier];\n\n    if (typeof resolver !== 'undefined') {\n      return typeof resolver === 'function' ? resolver(loggingEvent) : resolver;\n    }\n\n    return null;\n  }\n\n  function fileName(loggingEvent, specifier) {\n    let filename = loggingEvent.fileName || '';\n    if (specifier) {\n      const fileDepth = parseInt(specifier, 10);\n      const fileList = filename.split(path.sep);\n      if (fileList.length > fileDepth) {\n        filename = fileList.slice(-fileDepth).join(path.sep);\n      }\n    }\n\n    return filename;\n  }\n\n  function lineNumber(loggingEvent) {\n    return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : '';\n  }\n\n  function columnNumber(loggingEvent) {\n    return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : '';\n  }\n\n  function callStack(loggingEvent) {\n    return loggingEvent.callStack || '';\n  }\n\n  /* eslint quote-props:0 */\n  const replacers = {\n    c: categoryName,\n    d: formatAsDate,\n    h: hostname,\n    m: formatMessage,\n    n: endOfLine,\n    p: logLevel,\n    r: startTime,\n    '[': startColour,\n    ']': endColour,\n    y: clusterInfo,\n    z: pid,\n    '%': percent,\n    x: userDefined,\n    X: contextDefined,\n    f: fileName,\n    l: lineNumber,\n    o: columnNumber,\n    s: callStack\n  };\n\n  function replaceToken(conversionCharacter, loggingEvent, specifier) {\n    return replacers[conversionCharacter](loggingEvent, specifier);\n  }\n\n  function truncate(truncation, toTruncate) {\n    let len;\n    if (truncation) {\n      len = parseInt(truncation.substr(1), 10);\n      // negative truncate length means truncate from end of string\n      return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);\n    }\n\n    return toTruncate;\n  }\n\n  function pad(padding, toPad) {\n    let len;\n    if (padding) {\n      if (padding.charAt(0) === '-') {\n        len = parseInt(padding.substr(1), 10);\n        // Right pad with spaces\n        while (toPad.length < len) {\n          toPad += ' ';\n        }\n      } else {\n        len = parseInt(padding, 10);\n        // Left pad with spaces\n        while (toPad.length < len) {\n          toPad = ` ${toPad}`;\n        }\n      }\n    }\n    return toPad;\n  }\n\n  function truncateAndPad(toTruncAndPad, truncation, padding) {\n    let replacement = toTruncAndPad;\n    replacement = truncate(truncation, replacement);\n    replacement = pad(padding, replacement);\n    return replacement;\n  }\n\n  return function (loggingEvent) {\n    let formattedString = '';\n    let result;\n    let searchString = pattern;\n\n    /* eslint no-cond-assign:0 */\n    while ((result = regex.exec(searchString)) !== null) {\n      // const matchedString = result[0];\n      const padding = result[1];\n      const truncation = result[2];\n      const conversionCharacter = result[3];\n      const specifier = result[5];\n      const text = result[6];\n\n      // Check if the pattern matched was just normal text\n      if (text) {\n        formattedString += text.toString();\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);\n        formattedString += truncateAndPad(replacement, truncation, padding);\n      }\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n    return formattedString;\n  };\n}\n\nconst layoutMakers = {\n  messagePassThrough () {\n    return messagePassThroughLayout;\n  },\n  basic () {\n    return basicLayout;\n  },\n  colored () {\n    return colouredLayout;\n  },\n  coloured () {\n    return colouredLayout;\n  },\n  pattern (config) {\n    return patternLayout(config && config.pattern, config && config.tokens);\n  },\n  dummy () {\n    return dummyLayout;\n  }\n};\n\nmodule.exports = {\n  basicLayout,\n  messagePassThroughLayout,\n  patternLayout,\n  colouredLayout,\n  coloredLayout: colouredLayout,\n  dummyLayout,\n  addLayout (name, serializerGenerator) {\n    layoutMakers[name] = serializerGenerator;\n  },\n  layout (name, config) {\n    return layoutMakers[name] && layoutMakers[name](config);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}