{"ast":null,"code":"/* eslint no-underscore-dangle:0 */\nconst debug = require(\"debug\")(\"log4js:logger\");\n\nconst LoggingEvent = require(\"./LoggingEvent\");\n\nconst levels = require(\"./levels\");\n\nconst clustering = require(\"./clustering\");\n\nconst categories = require(\"./categories\");\n\nconst configuration = require(\"./configuration\");\n\nconst stackReg = /at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\n\nfunction defaultParseCallStack(data, skipIdx = 4) {\n  const stacklines = data.stack.split(\"\\n\").slice(skipIdx);\n  const lineMatch = stackReg.exec(stacklines[0]);\n\n  if (lineMatch && lineMatch.length === 6) {\n    return {\n      functionName: lineMatch[1],\n      fileName: lineMatch[2],\n      lineNumber: parseInt(lineMatch[3], 10),\n      columnNumber: parseInt(lineMatch[4], 10),\n      callStack: stacklines.join(\"\\n\")\n    };\n  }\n\n  return null;\n}\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\n\n\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error(\"No category provided.\");\n    }\n\n    this.category = name;\n    this.context = {};\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(categories.getLevelForCategory(this.category), levels.TRACE);\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level, levels.INFO);\n\n    if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const loggingEvent = new LoggingEvent(this.category, level, data, this.context, this.useCallStack && this.parseCallStack(new Error()));\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    this.parseCallStack = parseFunction;\n  }\n\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, g => g[1].toUpperCase());\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function () {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function (...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\nmodule.exports = Logger;","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/log4js/lib/logger.js"],"names":["debug","require","LoggingEvent","levels","clustering","categories","configuration","stackReg","defaultParseCallStack","data","skipIdx","stacklines","stack","split","slice","lineMatch","exec","length","functionName","fileName","lineNumber","parseInt","columnNumber","callStack","join","Logger","constructor","name","Error","category","context","parseCallStack","level","getLevel","getLevelForCategory","TRACE","setLevelForCategory","useCallStack","getEnableCallStackForCategory","bool","setEnableCallStackForCategory","log","args","logLevel","INFO","isLevelEnabled","_log","otherLevel","isLessThanOrEqualTo","loggingEvent","send","addContext","key","value","removeContext","clearContext","setParseCallStackFunction","parseFunction","addLevelMethods","target","levelStrLower","toString","toLowerCase","levelMethod","replace","g","toUpperCase","isLevelMethod","prototype","forEach","addListener","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-underscore-dangle:0 */\nconst debug = require(\"debug\")(\"log4js:logger\");\nconst LoggingEvent = require(\"./LoggingEvent\");\nconst levels = require(\"./levels\");\nconst clustering = require(\"./clustering\");\nconst categories = require(\"./categories\");\nconst configuration = require(\"./configuration\");\n\nconst stackReg = /at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\nfunction defaultParseCallStack(data, skipIdx = 4) {\n  const stacklines = data.stack.split(\"\\n\").slice(skipIdx);\n  const lineMatch = stackReg.exec(stacklines[0]);\n  if (lineMatch && lineMatch.length === 6) {\n    return {\n      functionName: lineMatch[1],\n      fileName: lineMatch[2],\n      lineNumber: parseInt(lineMatch[3], 10),\n      columnNumber: parseInt(lineMatch[4], 10),\n      callStack: stacklines.join(\"\\n\")\n    };\n  }\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error(\"No category provided.\");\n    }\n    this.category = name;\n    this.context = {};\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(\n      categories.getLevelForCategory(this.category),\n      levels.TRACE\n    );\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(\n      this.category,\n      levels.getLevel(level, this.level)\n    );\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level, levels.INFO);\n    if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const loggingEvent = new LoggingEvent(\n      this.category,\n      level,\n      data,\n      this.context,\n      this.useCallStack && this.parseCallStack(new Error())\n    );\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    this.parseCallStack = parseFunction;\n  }\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, g =>\n    g[1].toUpperCase()\n  );\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function() {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function(...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\n\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\n\nmodule.exports = Logger;\n"]},"metadata":{},"sourceType":"script"}