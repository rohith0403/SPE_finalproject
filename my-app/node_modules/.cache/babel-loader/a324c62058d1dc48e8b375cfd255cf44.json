{"ast":null,"code":"const debug = require('debug')('log4js:fileSync');\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst os = require('os');\n\nconst eol = os.EOL || '\\n';\n\nfunction touchFile(file, options) {\n  // if the file exists, nothing to do\n  if (fs.existsSync(file)) {\n    return;\n  } // touch the file to apply flags (like w to truncate the file)\n\n\n  const id = fs.openSync(file, options.flags, options.mode);\n  fs.closeSync(id);\n}\n\nclass RollingFileSync {\n  constructor(filename, size, backups, options) {\n    debug('In RollingFileStream');\n\n    function throwErrorIfArgumentsAreNotValid() {\n      if (!filename || !size || size <= 0) {\n        throw new Error('You must specify a filename and file size');\n      }\n    }\n\n    throwErrorIfArgumentsAreNotValid();\n    this.filename = filename;\n    this.size = size;\n    this.backups = backups || 1;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      let fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  shouldRoll() {\n    debug('should roll with current size %d, and max size %d', this.currentSize, this.size);\n    return this.currentSize >= this.size;\n  }\n\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n\n    function index(filename_) {\n      return parseInt(filename_.substring(`${path.basename(filename)}.`.length), 10) || 0;\n    }\n\n    function byIndex(a, b) {\n      if (index(a) > index(b)) {\n        return 1;\n      }\n\n      if (index(a) < index(b)) {\n        return -1;\n      }\n\n      return 0;\n    }\n\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n\n      if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {// ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);\n      }\n    }\n\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n      const files = fs.readdirSync(path.dirname(filename));\n      files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);\n    }\n\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  }\n  /* eslint no-unused-vars:0 */\n\n\n  write(chunk, encoding) {\n    const that = this;\n\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n\n    debug('in write');\n\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n\n    writeTheChunk();\n  }\n\n}\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param timezoneOffset - optional timezone offset in minutes\n *   (default system local)\n * @param options - passed as is to fs options\n */\n\n\nfunction fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {\n  debug('fileSync appender created');\n  file = path.normalize(file);\n  numBackups = numBackups === undefined ? 5 : numBackups; // there has to be at least one backup if logSize has been specified\n\n  numBackups = numBackups === 0 ? 1 : numBackups;\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(filePath, fileSize, numFiles, options);\n    } else {\n      stream = (f => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          }\n\n        };\n      })(filePath);\n    }\n\n    return stream;\n  }\n\n  const logFile = openTheStream(file, logSize, numBackups);\n  return loggingEvent => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o644\n  };\n  return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config.timezoneOffset, options);\n}\n\nmodule.exports.configure = configure;","map":{"version":3,"sources":["/Users/osurihimeshkrishna/Downloads/Academics/8th Semester/Software Production Engineering/spe_finalproject/my-app/node_modules/log4js/lib/appenders/fileSync.js"],"names":["debug","require","path","fs","os","eol","EOL","touchFile","file","options","existsSync","id","openSync","flags","mode","closeSync","RollingFileSync","constructor","filename","size","backups","throwErrorIfArgumentsAreNotValid","Error","currentSize","currentFileSize","fileSize","statSync","e","shouldRoll","roll","that","nameMatcher","RegExp","basename","justTheseFiles","item","test","index","filename_","parseInt","substring","length","byIndex","a","b","increaseFileIndex","fileToRename","idx","unlinkSync","renameSync","join","dirname","renameTheFiles","files","readdirSync","filter","sort","reverse","forEach","write","chunk","encoding","writeTheChunk","appendFileSync","fileAppender","layout","logSize","numBackups","timezoneOffset","normalize","undefined","openTheStream","filePath","numFiles","stream","f","data","logFile","loggingEvent","configure","config","layouts","basicLayout","type","maxLogSize","module","exports"],"mappings":"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","sourcesContent":["const debug = require('debug')('log4js:fileSync');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst eol = os.EOL || '\\n';\n\nfunction touchFile(file, options) {\n  // if the file exists, nothing to do\n  if (fs.existsSync(file)) {\n    return;\n  }\n\n  // touch the file to apply flags (like w to truncate the file)\n  const id = fs.openSync(file, options.flags, options.mode);\n  fs.closeSync(id);\n}\n\nclass RollingFileSync {\n  constructor(filename, size, backups, options) {\n    debug('In RollingFileStream');\n\n    function throwErrorIfArgumentsAreNotValid() {\n      if (!filename || !size || size <= 0) {\n        throw new Error('You must specify a filename and file size');\n      }\n    }\n\n    throwErrorIfArgumentsAreNotValid();\n\n    this.filename = filename;\n    this.size = size;\n    this.backups = backups || 1;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      let fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  shouldRoll() {\n    debug('should roll with current size %d, and max size %d', this.currentSize, this.size);\n    return this.currentSize >= this.size;\n  }\n\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n\n    function index(filename_) {\n      return parseInt(filename_.substring((`${path.basename(filename)}.`).length), 10) || 0;\n    }\n\n    function byIndex(a, b) {\n      if (index(a) > index(b)) {\n        return 1;\n      }\n      if (index(a) < index(b)) {\n        return -1;\n      }\n\n      return 0;\n    }\n\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n      if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {\n          // ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);\n      }\n    }\n\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n\n      const files = fs.readdirSync(path.dirname(filename));\n      files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);\n    }\n\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  }\n\n  /* eslint no-unused-vars:0 */\n  write(chunk, encoding) {\n    const that = this;\n\n\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n\n    debug('in write');\n\n\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n\n    writeTheChunk();\n  }\n}\n\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param timezoneOffset - optional timezone offset in minutes\n *   (default system local)\n * @param options - passed as is to fs options\n */\nfunction fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {\n  debug('fileSync appender created');\n  file = path.normalize(file);\n  numBackups = numBackups === undefined ? 5 : numBackups;\n  // there has to be at least one backup if logSize has been specified\n  numBackups = numBackups === 0 ? 1 : numBackups;\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(\n        filePath,\n        fileSize,\n        numFiles,\n        options\n      );\n    } else {\n      stream = (((f) => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          }\n        };\n      }))(filePath);\n    }\n\n    return stream;\n  }\n\n  const logFile = openTheStream(file, logSize, numBackups);\n\n  return (loggingEvent) => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o644\n  };\n\n  return fileAppender(\n    config.filename,\n    layout,\n    config.maxLogSize,\n    config.backups,\n    config.timezoneOffset,\n    options\n  );\n}\n\nmodule.exports.configure = configure;\n"]},"metadata":{},"sourceType":"script"}